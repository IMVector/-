---
title: 问题记录
date: 2021-02-06 18:27:00
tags:
---

<!--将该代码放入博客模板的head中即可-->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
  inlineMath: [['$','$'], ['\\(','\\)']],
  processEscapes: true
  }
});
</script>
<!--latex数学显示公式-->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


# [部分原文](https://leetcode-cn.com/circle/discuss/5szs6p/)

# 一、Java 基础相关
## 1.1 数据结构与算法

### 1.1.1 常用的数据结构有哪些?
```
数组、链表、树（二叉树、二叉搜索树、红黑树）、图（有向图，无向图）、栈、队列、散列表
```
### 1.1.2 数组
（1）如何在一个 1 到 100 的整数数组中找到丢失的数字?
   ```
   原地哈希表O（n）
   ```

（2）如何在给定的整数数组中找到重复的数字? （小米）
   ```
   哈希表
   原地哈希表
   ```

（3）如何在未排序整数数组中找到最大值和最小值?（字节跳动）

- 使用两个值记录最大值和最小值, 每次取出两个值,先进行比较,小的与最小值比较,大的与最大值比较 , 比较次数: 1.5∗N
- 将相邻的数进行比较,大的放在偶数位置,小的放在奇数位置, 最后奇数位置比较和偶数位置对应比较,得到最大值和最小值,比较次数: $1.5∗N$ ;

[東木:无序数组中求最大值和最小值的最少比较次数](https://www.cnblogs.com/hugochen1024/p/12570824.html)


[作者：逃之不桃链接：来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。](https://www.jianshu.com/p/96fa355e1faf)
   ```c
// 思路是类似于快速排序的分组方式，对数组从两头进行分组，
// 即第0个元素与第n-1个元素进行对比，大的放a组，小的放b组；
// 然后第一个与n-2进行对比........直到两边序号重合，比较次数为n/2，
// 这时，最大的数肯定在a组里，最小的数肯定在b组。
// 然后再在a组里寻找最大值，再在b组里寻找最小值，分别都是n/2次比较，
// 一共使用3/2n次比较就搞定啦。

   void findMaxandMinNumber(int nums[], int count) {
    //分组
    int i = 0;
    for (; i < (count - i - 1); i++) {
        if (nums[i]<nums[count-1-i]) {
            //交换位置
            int tem = nums[i];
            nums[i] = nums[count-i-1];
            nums[count-i-1] = tem;
        }
    }
    int sep = 0;
    int middle = 0;
    if (i == count-i-1) {
        //奇数
        sep = count/2+1;
        middle = nums[count/2];
    } else {
        //偶数
        sep = count/2;
    }
    //大的一组
    int max = nums[0];
    for (int j=1; j<count/2-1; j++) {
        if (nums[j]>max) {
            max = nums[j];
        }
    }
    //小的一组
    int min = nums[sep];
    for (int j=sep+1; j<count-1; j++) {
        if (nums[j]<min) {
            min = nums[j];
        }
    }
    
    //与middle进行对比
    if (i == count-i-1) {
        if (middle>max) {
            max = middle;
        }
        if (middle<min) {
            min = middle;
        }
    }
    
    printf("max = %d, min = %d", max, min);
}
   ```

（4）在 Java 中如何从给定数组中删除多重复制?

（5）大数相加(今日头条)
```
字符串求和
```

### 1.1.3 链表
（1）那查询第一个跟倒数第二个呢？（这就不一样了，第一个直接给了头结点，倒数第二个需要从倒数第一个开始查询，走两步） （腾讯）
```
倒数第二个节点：
1、如果是双向链表的话直接返回从尾节点开始的第二个节点
2、如果是普通链表，需要两个指针，一前一后，前面的那个到尾节点，返回后面的那个节点
```
（2）arrayList 底层原理 （滴滴 字节跳动）
```
- ArrayList底层是数组，默认大小是10，默认值是空
- 实现List接口的动态数组，容量大小为 capacity，默认的容量大小 10，会自动扩容
- 可包含空元素 null
- size, isEmpty, get, set, iterator, and listIterator 等操作的复杂度为 O(1)，
The add operation runs in amortized constanttime, 
that is, adding n elements requires O(n) time，其它操作为线性时间
- 非线程安全，多线程环境下必须在外部增加同步限制，
或者使用包装对象 List list = Collections.synchronizedList(new ArrayList(...));
- 快速失败：在使用迭代器时，调用迭代器的添加、修改、删除方法，
将抛出 ConcurrentModificationException 异常，
但是快速失败行为不是硬证的，只是尽最大努力
```
（3）如何在一次遍历中找到单个链表的中值?（中国平安）
```
中值指中间位置的值？

快慢指针，快指针一次走两步，慢指针一次走一步

如果是中间大小的值，需要用插入排序了
```

（4）如何证明给定的链表是否包含循环?如何找到循环的头节点? （优酷）
```
快慢指针，快指针每次走两步，慢指针每次走一步，快慢指针相遇时，说明有环

当快慢指针相遇时，从头节点出发一个慢指针，当新的慢指针与旧的慢指针相遇时，说明时循环的头节点
```

（5）两个有交叉的单链表，求交叉点 （华为）
```

p1->A->B
p2->B->A
当两个指针相遇时便是交叉点
```
（6）如何得到单链表的长度? 360
```
快慢指针O(n/2)
```

（7）如何在不使用递归的情况下逆转单链表? （小米/美团）
```
维护一个dummy节点
```

（8）怎么判断链表有环？ （滴滴）

```
快慢三指针
```

### 1.1.4 队列&堆栈
（1）如何使用栈实现队列的功能？(广州荔枝 FM)
```
两个栈可以实现一个队列

1、入栈时，往A栈里面添加元素

2、出栈时，把A栈里面的元素pop并push到B，从B出栈，while(B)不为空，一直从B出栈，
否则把A栈里面的元素pop并push到B。
```

（2）两个栈实现一个队列 （蘑菇街）
```
答案如上
```
（3）两个队列实现一个栈 （腾讯）
```java
/*
 添加元素时默认往queue2中offer()，并将queue1中的所有元素poll()并offer到queue2中去，交换queue1和queue2

 出栈时，从queue1中poll，因为queue1中的所有元素都是按照栈中的元素排好了
*/
class MyStack {
    Queue<Integer> queue1;
    Queue<Integer> queue2;

    public MyStack() {
        queue1 = new LinkedList<Integer>();
        queue2 = new LinkedList<Integer>();
    }
    
    public void push(int x) {
        queue2.offer(x);
        while (!queue1.isEmpty()) {
            queue2.offer(queue1.poll());
        }
        Queue<Integer> temp = queue1;
        queue1 = queue2;
        queue2 = temp;
    }
    
    public int pop() {
        return queue1.poll();
    }
    
    public int top() {
        return queue1.peek();
    }
    
    public boolean empty() {
        return queue1.isEmpty();
    }
}


```
（4）对比一下队列和栈，以及它们底部实现 （腾讯）
```
队列和栈都可以用链表实现，队列只可以从头部出队，尾部入队，栈只可以从尾部操作，入栈和出栈操作都是在尾部进行的。

在Java中一般使用linkedList作为栈和队列的实现
```
### 1.1.5 二叉树
（1）如何在给定的二叉树中执行先序遍历?（百度）
```
先序遍历是：根，左，右 
递归:输出根节点的值，遍历左子树，遍历右子树
```
（2）如何实现后序遍历算法? （百度）
```
后序遍历是：左，右，根
递归：遍历左子树，遍历右子树，输出根节点的值
```

（3）如何在给定数组中执行二分法搜索? （苏宁）
```
如果有序，直接进行二分
如果无序，需要先进行排序，再进行二分
```

（4）已知前序遍历为 {1,2,4,7,3,5,6,8}，中序遍历为 {4,7,2,1,5,3,8,6}，它的二叉树是怎么样的？ 58
```
再中序遍历中没有重复数字时：
使用MashMap存储中序遍历的值和index的关系

根据前序遍历找到根节点，根据该根节点找到中序遍历中该节点的index，通过index计算左子树中元素的数量和右子树中元素的数量（可以进一步的找到左子树的根节点的位置和右子树的根节点的位置），递归的建立树。

```

（5）输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。 （爱奇艺）
```
递归： 
A的当前节点是否与B的当前节点相同，

如果相同，那么比较A的左子树和B的右子树

如果不同，比较A的左子树与B，比较A的右子树与B
```
（6）请实现两个函数，分别用来序列化二叉树和反序列化二叉树。 （YY）
```
前序遍历二叉树，空节点使用#号代替，遍历完成后遍历序列中元素的数量和完全二叉树的遍历的数量是相同的

还原二叉树时，使用前序构建方法构建二叉树
```
（7）平衡二叉树和红黑树的区别？（字节跳动）
```
AVL树时带有平衡条件的二叉查找树，一般时用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高差值不超过1，和红黑树比，ALVL树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差的绝对值不超过1）.不管我们是执行插入炒作还是删除炒作，只有不满足上述条件就要通过旋转来保持平衡，旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除较少，而查询较多的情况。

由于维护这种搞得平衡所付出的代价比从中获得的效益还大，故而实际的应用不多，更多的是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中队插入删除不频繁，只是对查找的要求较高，那么AVL还是优于红黑树。

一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度低于红黑树），相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，我们就用红黑树。

版权声明：本文为CSDN博主「Charles_yy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u010899985/article/details/80981053
```
（8）什么是平衡二叉树，它有什么特征 （美团）
```
AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1，

和红黑树相比，AVL树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差的绝对值不超过1）。

不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，

由此我们可以知道AVL树适合用于插入与删除次数比较少，但查找多的情况

————————————————
版权声明：本文为CSDN博主「Charles_yy」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u010899985/article/details/80981053
```
（9）B 树，B+树

```
B树又叫做B-树

B树也称B-树,它是一颗多路平衡查找树。B树的定义。

每个节点最多有m-1个关键字（可以存有的键值对）。
根节点最少可以只有1个关键字。
非根节点至少有m/2个关键字。
每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。
所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。
每个节点都存有索引和数据，也就是对应的key和value。
所以，根节点的关键字数量范围：1 <= k <= m-1，非根节点的关键字数量范围：m/2 <= k <= m-1。

B+树


B+树其实和B树是非常相似的，我们首先看看**相同点**。

- 根节点至少一个元素
- 非根节点元素范围：m/2 <= k <= m-1

**不同点**。

- B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。
- 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。
- 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。
- 父节点存有右孩子的第一个元素的索引。
```

### 1.1.6 HashMap
（1）HashMap 的底层原理是什么？线程安全么？ （百度 美团）
```
HashMap在JDK1.8之前使用数组和链表实现
在JDK1.8之后使用数组、链表和红黑树实现

HashMap不是线程安全的
```
（2）HashMap 中 put 是如何实现的？ （滴滴）
```
（1）计算key的hash值；

（2）如果桶（数组）数量为0，则初始化桶；

（3）如果key所在的桶没有元素，则直接插入；

（4）如果key所在的桶中的第一个元素的key与待插入的key相同，说明找到了元素，转后续流程（9）处理；

（5）如果第一个元素是树节点，则调用树节点的putTreeVal()寻找元素或插入树节点；

（6）如果不是以上三种情况，则遍历桶对应的链表查找key是否存在于链表中；

（7）如果找到了对应key的元素，则转后续流程（9）处理；

（8）如果没找到对应key的元素，则在链表最后插入一个新节点并判断是否需要树化；

（9）如果找到了对应key的元素，则判断是否需要替换旧值，并直接返回旧值；

（10）如果插入了元素，则数量加1并判断是否需要扩容；
```
（3）谈一下 hashMap 中什么时候需要进行扩容，扩容 resize()又是如何实现的？
```
插入元素时，如果当前的数量大于Threshold时，需要对其进行扩容，threshold的计算是当前哈希表的大小*loadFactor

（1）如果使用是默认构造方法，则第一次插入元素时初始化为默认值，容量为16，扩容门槛为12；

（2）如果使用的是非默认构造方法，则第一次插入元素时初始化容量等于扩容门槛，扩容门槛在构造方法里等于传入容量向上最近的2的n次方；

（3）如果旧容量大于0，则新容量等于旧容量的2倍，但不超过最大容量2的30次方，新扩容门槛为旧扩容门槛的2倍；

（4）创建一个新容量的桶；

（5）搬移元素，原链表分化成两个链表(原红黑树分成两棵树)，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置；
```

（4）什么是哈希碰撞？怎么解决? （滴滴 美团）
```
哈希碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中

链表法和开放地址法。链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。java.util.HashMap采用的链表法的方式，链表是单向链表。
```

（5）HashMap 和 HashTable 的区别 （小米）
```
1.安全性
Hashtable是线程安全，HashMap是非线程安全。HashMap的性能会高于Hashtable，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步
2.是否可以使用null作为key
HashMap可以使用null作为key，不过建议还是尽量避免这样使用。HashMap以null作为key时，总是存储在table数组的第一个节点上。而Hashtable则不允许null作为key
3.继承了什么，实现了什么
HashMap继承了AbstractMap，HashTable继承Dictionary抽象类，两者均实现Map接口
4.默认容量及如何扩容
HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。HashMap扩容时是当前容量翻倍即:capacity  2，Hashtable扩容时是容量翻倍+1即:capacity  (2+1)
6.底层实现
HashMap和Hashtable的底层实现都是数组+链表结构实现
7.计算hash的方法不同
Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取模

8.扩容和默认大小不同
可以看到HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。HashMap默认的初始化大小为16，之后每次扩充为原来的2倍。

作者：淼淼之森
链接：https://juejin.cn/post/6844903925460500487
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
（6）HashMap 中什么时候需要进行扩容，扩容 resize()是如何实现的？ （滴滴）

（7）hashmap concurrenthashmap 原理 （美团）
```

```
（8）arraylist 和 hashmap 的区别，为什么取数快？（字节跳动）
```
ArrayList和HashMap的底层实现不一样

ArrayList的底层实现是数组，而HashMap的底层实现是数组+链表+红黑树（JDK1.8）

从数据结构上来说，两者的数据结构不一样，分别是数组和哈希表
还有各种参数不同，ArrayList的默认大小是10，扩容是1.5倍，
hashMap的默认大小是16，扩容是两倍

ArrayList的取数快是因为在存储时是数组，连续存储，数组的访问时间复杂度是O(1)

HashMap 的取数快是因为使用了hash算法定位桶的index，并且桶是使用数组存储的，此外还是使用了红黑树加速查询（在有哈希冲突的时候）

```
### 1.1.7图
（1）旋转输出矩阵
```
行列转换
列转换
```
（2）给定一个矩阵 int matrixA[m][n]，每行每列都是增序的，实现一个算法去寻找矩阵中的某个元素 element. 搜狗
```
从最右上角遍历
每次删除一行或者一列
```
### 1.1.8排序算法有哪些？
（1）top-k 排序(堆排序，位图法) （美团）

```java
class Solution {
    public int[] smallestK(int[] arr, int k) {
        randomizedSelected(arr, 0, arr.length - 1, k);
        int[] vec = new int[k];
        for (int i = 0; i < k; ++i) {
            vec[i] = arr[i];
        }
        return vec;
    }

    private void randomizedSelected(int[] arr, int l, int r, int k) {
        if (l >= r) {
            return;
        }
        int pos = randomizedPartition(arr, l, r);
        int num = pos - l + 1;
        if (k == num) {
            return;
        } else if (k < num) {
            randomizedSelected(arr, l, pos - 1, k);
        } else {
            randomizedSelected(arr, pos + 1, r, k - num);
        }
    }

    // 基于随机的划分
    private int randomizedPartition(int[] nums, int l, int r) {
        int i = new Random().nextInt(r - l + 1) + l;
        swap(nums, r, i);
        return partition(nums, l, r);
    }

    private int partition(int[] nums, int l, int r) {
        int pivot = nums[r];
        int i = l - 1;
        for (int j = l; j <= r - 1; ++j) {
            if (nums[j] <= pivot) {
                i = i + 1;
                swap(nums, i, j);
            }
        }
        swap(nums, i + 1, r);
        return i + 1;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/smallest-k-lcci/solution/zui-xiao-kge-shu-by-leetcode-solution-o5eg/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
（2）冒泡排序的手写 （华捷艾米）
```java
for(int i=0;i<n;i++){
    for(int j=0;j<len-1-i;j++){
        if(nums[j]>nums[j+1]){
            swap(nums,j,j+1);
        }
    }
}

```
（3）堆排序算法的手写 （华捷艾米）
```java
public void buildMaxHeap(int []nums){
    int heapSize=nums.length;
    for(int i=heapSiez/2;i>=0;i--){
        maxHeapify(nums,i,heapSize);
    }
}
public void maxHeapify(int []nums,int i,int heapSize){
    int l=2*i+1,r=2*i+2,largest=i;
    if(l<heapSize&&nums[largest]<nums[l])largets=l;
    if(r<heapSize&&nums[largest]<nums[r])largest=r;
    if(largest!=i){
        swap(nums,i,largest);
        maxHeapify(nums,largest,heapSize);
    }

}

public void swap(int []nums,int index1,int index2){
    int temp=nums[index1];
    nums[index1]=nums[index2];
    nums[index2]=temp;
}
```
（4）椭圆形场地有两个赛道，可以同时提供两匹马比赛，两匹马比赛后，可以获知两匹马中跑的快的那匹马，但是没有计时工具。问题，如何最优的算法(比赛次数最少)，获知 10 匹马中速度最快的三匹马 （阿里）

```java
// 锦标赛排序
public class TournamentSort {
	private class Node{
        //用node来存储竞赛排序过程中的节点，包括里面的数据和数据在数组中的ID
		public int data;
		public int id;
		
		public Node(){}
		public Node(int _data, int _id){
			data = _data;
			id = _id;
		}
	}
	public void Adjust(Node[] data, int idx){//当去除最小元素以后，我们要调整数组
		while(idx != 0){
			if(idx % 2 == 1){//当前id是奇数，说明并列的是idx + 1, 父节点是 (idx-1)/2
				if(data[idx].data < data[idx + 1].data){
					data[(idx - 1)/2] = data[idx];
				}else{
					data[(idx-1)/2] = data[idx + 1];
				}
				idx = (idx - 1)/2;
			}
			else{
				if(data[idx-1].data < data[idx].data){
					data[idx/2 - 1] = data[idx-1];
				}else{
					data[idx/2 - 1] = data[idx];
				}
				idx = (idx/2 - 1);
			}
		}
	}
	
	
	public void Sort(int[] data){
		int nNodes = 1;
		int nTreeSize;
		while(nNodes < data.length){
			nNodes *= 2;
		}
		nTreeSize = 2 * nNodes - 1;//竞赛树节点的个数, nNode算出来是为了做成满二叉树
		
		Node[] nodes = new Node[nTreeSize];//竞赛树用数组存储
		//initialize the data
		
		int i, j;
		int idx;
		for( i = nNodes - 1; i < nTreeSize; i++) {//初始化竞赛树数据
			idx = i - (nNodes - 1);
			if(idx < data.length){
				nodes[i] = new Node(data[idx], i);
			}else{
			    nodes[i] = new Node(Integer.MAX_VALUE, -1);//对于补充的数据，我们初始化成最大。
			}
		}
		
		for( i = nNodes - 2; i >= 0; i--){
			nodes[i] = new Node();
			if(nodes[i * 2 + 1].data < nodes[i * 2 + 2].data){
				nodes[i] = nodes[i*2 + 1];
			}else{
				nodes[i] = nodes[i*2 + 2];
			}
		}
		//the real sorting procedure
		for( i = 0; i < data.length; i++){//实际排序的过程
			data[i] = nodes[0].data;//取出最小的
			nodes[nodes[0].id].data = Integer.MAX_VALUE;
			Adjust(nodes, nodes[0].id);
			
		}
	}
}
```

（5）输入一个整型无序数组，对堆排序的方法使得数组有序 （阿里）
```java
public void buildMaxHeap(int []nums){
    int heapSize=nums.length;
    for(int i=heapSiez/2;i>=0;i--){
        maxHeapify(nums,i,heapSize);
    }
}
public void maxHeapify(int []nums,int i,int heapSize){
    int l=2*i+1,r=2*i+2,largest=i;
    if(l<heapSize&&nums[largest]<nums[l])largets=l;
    if(r<heapSize&&nums[largest]<nums[r])largest=r;
    if(largest!=i){
        swap(nums,i,largest);
        maxHeapify(nums,largest,heapSize);
    }

}

public void swap(int []nums,int index1,int index2){
    int temp=nums[index1];
    nums[index1]=nums[index2];
    nums[index2]=temp;
}
```
（6）如何使用快速排序算法对整数数组进行排序? （CVTE）
```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        quickSort(arr, 0, arr.length - 1);
        return Arrays.copyOf(arr, k);
    }
    private void quickSort(int[] arr, int l, int r) {
        // 子数组长度为 1 时终止递归
        if (l >= r) return;
        // 哨兵划分操作（以 arr[l] 作为基准数）
        int i = l, j = r;
        while (i < j) {
            // 右边的大于哨兵，不需要交换
            while (i < j && arr[j] >= arr[l]) j--;
            // 左边的小于哨兵，也不需要交换
            while (i < j && arr[i] <= arr[l]) i++;
            // 找到需要交换的值，进行交换
            swap(arr, i, j);
        }
        // 将哨兵交换到分界位置
        swap(arr, i, l);
        // 递归左（右）子数组执行哨兵划分
        quickSort(arr, l, i - 1);
        quickSort(arr, i + 1, r);
    }
    private void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/jian-zhi-offer-40-zui-xiao-de-k-ge-shu-j-9yze/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 1.1.9 查找算法
（1）有序数组的二分查找算法 （百度）

### 1.1.10 串
（1）给定一个字符串，请你找出其中不含有重复字符的 最长子串的长度。 （字节跳动）
```java
// 滑动窗口，遇到重复字符时，收缩左窗口
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int max = 0;
        int l = 0, r = 0;
        for (int i = 0; i < s.length(); i++) {
            r = i;
            if (set.contains(s.charAt(i))) {
                while (l < r) {
                    max = Math.max(r - l, max);
                    if (s.charAt(l) != s.charAt(i)) {
                        set.remove(s.charAt(l));
                        l++;
                    } else {
                        l++;
                        break;
                    }
                }
            } else {
                set.add(s.charAt(i));
            }
        }

        return Math.max(max, set.size());
    }
}
```
（2）给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
```java
// 枚举回文中心字符串
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return "";
        }
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = Math.max(len1, len2);
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }

    public int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            --left;
            ++right;
        }
        return right - left - 1;
    }
}
// 动态规划
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        String ans = "";
        // 枚举子字符串的长度
        for (int l = 0; l < n; ++l) {
            // 枚举每个字符
            for (int i = 0; i + l < n; ++i) {
                int j = i + l;
                if (l == 0) {// 也就是dp[i][j]=true 一个字符自身肯定是回文的
                    dp[i][j] = true;
                } else if (l == 1) {// 相邻的两个字符是相同的那么这两个字符是回文的
                    dp[i][j] = (s.charAt(i) == s.charAt(j));
                } else {
                    // dp[i+1][j-1]其中i+1是向右移动左边界，j-1是向左移动右边界，即如果当前的相同并且靠近回文中心的也相同，那么i和j对应的也相同（需要自内而外计算）
                    dp[i][j] = (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]);
                }
                // 其中l是枚举的区间的长度
                if (dp[i][j] && l + 1 > ans.length()) {
                    ans = s.substring(i, i + l + 1);
                }
            }
        }
        return ans;
    }
}
```
### 1.1.11 请写出以下算法的时间复杂度
冒泡排序法 插入排序法 堆排序法 二叉树排序法
```
冒泡排序法 插入排序法   堆排序法        二叉树排序法
 O(N*N)     O(N*N)    O(N*log(N))     O(N*log(N))
```

### 1.1.12 其他算法
（1）常用的对称加密算法，有什么同？ （字节跳动）
| 名称  | 密钥长度                 | 运算速度 | 安全性 | 资源消耗 | 加密类型   |
| :---- | :----------------------- | :------- | :----- | :------- | :--------- |
| DES   | 56位                     | 较快     | 低     | 中       | 对称加密   |
| 3DES  | 168位                    | 慢       | 中     | 高       | 对称加密   |
| IDEA  | 128位                    | 较慢     | 中     | 高       | 对称加密   |
| AES   | 128、192、256位          | 快       | 高     | 低       | 对称加密   |
| RSA   | 1024、2048、3072、4096位 | 慢       | 高     | 高       | 非对称加密 |
| DSA   | 1024、2048、3072、4096位 | 慢       | 高     | 低       | 非对称加密 |
| ECC   | 256                      | 快       | 高     | 低       | 非对称加密 |
| SHA-1 |                          | 慢       | 高     | 低       | Hash加密   |
| MD5   |                          | 快       | 中     | 低       | Hash加密   |

（2）如何在无序（有负数）的数组中查找是否存在和为 target 的两个数组合，twoSum(); （字节）
```
Map.containsKey(target-curNum)
使用HashMap加速，时间复杂度O(n)
```

## 1.2 Java 基础

（1）什么情况下会发生栈内存溢出？
```java
一、 栈溢出(StackOverflowError)
栈是线程私有的，他的生命周期与线程相同，
每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口灯信息。
局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化）

所以我们可以理解为栈溢出就是方法执行是创建的栈帧超过了栈的深度。
那么最有可能的就是方法递归调用产生这种结果。


————————————————
版权声明：本文为CSDN博主「LJHSkyWalker」的原创文章，
遵循CC 4.0 BY-SA版权协议，
转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_31615049/article/details/82980799

如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，
但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，
那么Java虚拟机将抛出一个OutOfMemory 异常。(线程启动过多)

public class JvmTest {
	private int i = 0;
	public void a(){
		System.out.println(i++);
		a();
	}
	public static void main(String[] args) {
		JvmTest j = new JvmTest();
		j.a();
	}
}

如何解决：

我们需要使用参数 -Xss 去调整JVM栈的大小
```
（2）如果让你写一段栈溢出的代码你会什么写，一个栈大概有多大，为什么？每个线程都有这样大小的一个栈吗？ （美团）

（3）JVM 中一次完整的GC流程是怎样的，对象如何晋升到老年代？
```
Java堆 = 老年代 + 新生代
新生代 = Eden + S0 + S1
当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。
大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；
如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，
每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。
老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC  清理整个内存堆 – 包括年轻代和年老代。
Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。

作者：捡田螺的小男孩
链接：https://juejin.cn/post/6844903895123099662
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
（4）介绍下 GC 回收机制与分代回收策略。
```java

```
（5）Java 中有几种引用关系，它们的区别是什么？
```
强引用、软引用、弱引用、虚引用
（1）强引用：在Java中最常见的就是强引用。在把一个对象赋给一个引用变量时，这个引用变量就是一个强引用。
有强引用的对象一定为可达性状态，所以不会被垃圾回收机制回收。因此，强引用是造成Java内存泄漏（Memory Link）的主要原因。

（2）软引用：软引用通过SoftReference类实现。如果一个对象只有软引用，则在系统内存空间不足时该对象将被回收。

（3）弱引用：弱引用通过WeakReference类实现，如果一个对象只有弱引用，则在垃圾回收过程中一定会被回收。

（4）虚引用：虚引用通过PhantomReference类实现，虚引用和引用队列联合使用，主要用于跟踪对象的垃圾回收状态。
```

（6）GC 收集算法有哪些？它们的特点是什么？
```
标记清除

复制

标记整理
```

（7）如何判断一个对象是否被回收，有哪些 GC 算法，实际虚拟机使用最多的是什么 GC 算法？（美团）
```
引用计数法（两个对象相互引用也就是循环引用）
可达性分析（从GC root开始进行可达性分析）根搜索算法
标记清除
复制
标记整理
```
（8）Jvm 内存 结构说一下。 a.描述 JVM 内存模型。（东方头条）
```
线程公共区域：方法区、堆（1/3新生代，1/3老年代）
线程私有区域：虚拟机栈、本地方法区、程序计数器
直接内存
```
（9）JVM DVM ART 的区别（360）

（10）描述 GC 机制。Class 会不会回收？用不到的 Class 怎么回收？(东方头条)
```
方法区的垃圾收集主要回收两部分：废弃的常量和不再使用的类型。判定一个常量是否废弃相对简单，与对象类似，只要某个常量不再被引用，就会被清理。而判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了，需要同时满足下面三个条件：

该类的所有实例都已经被回收，即 Java 堆中不存在该类及其任何派生子类的实例

加载该类的类加载器已经被回收

该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

Java 虚拟机允许对满足上述三个条件的无用类进行回收，但并不是说必然被回收，仅仅是允许而已。关于是否要对类型进行回收，HotSpot 虚拟机提供了 -Xnoclassgc 参数进行控制
————————————————
版权声明：本文为CSDN博主「陆翎」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_30682043/article/details/113051854
```
（11）StackOverFlow 与 OOM 的区别？分别发生在什么时候，JVM 栈中存储的是什么，堆存储的是什么？（美团）

（12）Java 虚拟机和 Dalvik 虚拟机的区别？

（13）请描述 new 一个对象的流程。[new 一个对象的流程](https://blog.csdn.net/SmartShylyBoy/article/details/109653745)
```
以person对象为例

通过双亲委派机制加载类->初始化类->构建对象：首先main线程会在栈中申请一个自己的栈空间，然后调用main方法后会生成一个main方法的栈帧。
然后执行new Person() ，这里会根据Person类元信息先确定对象的大小，向JVM堆中申请一块内存区域并构建对象，
同时对Person对象成员变量信息并赋默认值。
->初始化对象：然后执行对象内部生成的init方法，初始化成员变量值，
同时执行搜集到的{}代码块逻辑，最后执行对象构造方法
->引用对象：对象实例化完毕后，再把栈中的Person对象引用地址指向Person对象在堆内存中的地址。

```
（14）Java 对象会不会分配到栈中？
[求你了，别再说Java对象都是在堆内存上分配空间的了！](https://www.cnblogs.com/hollischuang/p/12501950.html)
```
Java编译器经过解释执行，其执行速度必然会比直接执行可执行的二进制字节码慢很多。
为了解决这种效率问题，引入了 JIT（Just In Time ，即时编译） 技术。

有了JIT技术之后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。
在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，
就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。

通过标量替换，原本的一个对象，被替换成了多个成员变量。而原本需要在堆上分配的内存，
也就不再需要了，完全可以在本地方法栈中完成对成员变量的内存分配。
```

（15）String， Stringbuffer， StringBuilder 的区别是什么？（东方头条）a.String StringBuffer StringBuilder 在进行字符串操作时的效率；这里主要考察 String 在内存中是如何创建的。（字节跳动）
```
都是final类，都不允许被继承；

String类长度是不可变的，StringBuffer和StringBuilder类长度是可以改变的；

StringBuffer类是线程安全的，StringBuilder不是线程安全的；
```
（16）String 为什么是不可变的？（字节跳动）a.String为什么设计成final的？

（17）final 、finally、finalize 区别。
```
#### 一、final ：

1、修饰符（关键字） 如果一个**类**被声明为final,意味着它**不能再派生新的子类，不能作为父类被继承**。
 【因此一个类不能及被声明为abstract，又被声明为final的。】

2、将**变量或方法**声明为final,可以保证他们使用中**不被改变**。被声明为final的变量必须在声明时给定初值，而以后的引用中只能读取，不可修改，被声明为final的方法也同样只能使用，不能重载。

#### 二、finally:

在**异常处理**时提供finally块来执行清楚操作。如果抛出一个异常，那么相匹配的catch语句就会执行，然后控制就会进入finally块，如果有的话。

#### 三、finalize：

是方法名。java技术允许**使用finalize()方法在垃圾收集器将对象从内存中清除之前做必要的清理工作**。这个方法是在垃圾收集器在确定了，被清理对象没有被引用的情况下调用的。

finalize是在Object类中定义的，因此，所有的类都继承了它。子类可以覆盖finalize()方法，来整理系统资源或者执行其他清理工作。
```
（18）抽象类和接口的区别。

（19）重载和重写的区别 （京东）
```
重载是方法上的（方法的签名不同，可以有不同的实现），重写是用在父类和子类上的（父类和子类的方法的实现不同）

重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！

重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。

重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。

方法的重写规则
参数列表与被重写方法的参数列表必须完全相同。

返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。

访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。

父类的成员方法只能被它的子类重写。

声明为 final 的方法不能被重写。

声明为 static 的方法不能被重写，但是能够被再次声明。

子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。

子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。

重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。

构造方法不能被重写。

如果不能继承一个类，则不能重写该类的方法。
------------------------------------------------------------------------------------------------

重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

最常用的地方就是构造器的重载。

重载规则:

被重载的方法必须改变参数列表(参数个数或类型不一样)；
被重载的方法可以改变返回类型；
被重载的方法可以改变访问修饰符；
被重载的方法可以声明新的或更广的检查异常；
方法能够在同一个类中或者在一个子类中被重载。
无法以返回值类型作为重载函数的区分标准。

```
（20）什么是值传递和引用传递，Java 是值传递还是引用传递？
```
java都是“值传递”即可，关键看这个值是什么，简单变量就是复制了具体值，引用变量就是复制了地址。
```
（21）String s = new String(“”);创建了几个对象?
```
一到两个对象
```
（22）java 里 equals和== 区别。
```
== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，
即是否是指相同一个对象。比较的是真正意义上的指针操作。基本数据类型中比较的是值是否相等。

equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，
所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，
而Object中的equals方法返回的却是==的判断。
```
（23）try-catch-finally，try 里有 return，finally 还执行么？
```
执行，但是不会改变try中返回值
```
（24）Excption 与 Error 区别。
```
Exception 分为运行时异常和检查异常，运行时异常可以被处理
ERROR是不可以被处理的

**①.Exception（异常）是应用程序中可能的可预测、可恢复问题。**一般大多数异常表示中度到轻度的问题。异常一般是在特定环境下产生的，通常出现在代码的特定方法和操作中。在 EchoInput 类中，当试图调用 readLine 方法时，可能出现 IOException 异常。
 Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。
 **②.Error（错误）**表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。
 检查异常 和 未检查异常 的划分
```
（25）Static class 与 non static class 的区别。
```

- 静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。

- 非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。

- 一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。

```
（26）PathClassLoader 与 DexClassLoader 的区别是什么？

（27）什么是双亲委托机制，为什么需要双亲委托机制？

（28）描述 JVM 类加载过程。

（29）动态代理是什么？如何实现？
```
AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。

jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。
```
（30）动态代理的方法怎么初始化的？（字节跳动）

（31）CGLIB 动态代理（字节跳动）

（32）说说反射的应用场景，哪些框架，原理是什么？

（33）Java 泛型的特点与优缺点，泛型擦除是怎么回事？

（34）List 能否转为 List。

（35）泛型 super 和 extends 的区别。a.说法 2：Java 的泛型，<? super T> 和 <? extends T> 的区别。

（36）为什么 IO 是耗时操作？

## 1.3 并发编程

（1）假如只有一个 cpu，单核，多线程还有用吗 ？（美团）
```
有用，只有有IO就有用
```
（2）sychronied 修饰普通方法和静态方法的区别？什么是可见性?
```
一个是对当前实例，一个是对这个类的所有实例
```
（3）锁分哪几类？
```
悲观锁、乐观锁

自旋锁、轻量级锁、重量级锁

独享锁、共享锁

公平锁和非公平锁（偏向锁）

可重入锁和不可重入锁

分段锁
监视器锁
mutex锁
```

（4）CAS 无锁编程的原理。（字节跳动）

（5）ReentrantLock 的实现原理。
```
https://juejin.cn/post/6844903805683761165
```

（6）AQS 原理 （小米 京东）

（7）Synchronized 的原理以及与 ReentrantLock 的区别。（360）
```
协调多线程对共享对象、变量的访问
可重入，同一线程可以多次获得同一个锁
都保证了可见性和互斥性
两者的不同点：
ReentrantLock显示获得、释放锁，synchronized隐式获得释放锁
ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性
ReentrantLock是API级别的，synchronized是JVM级别的
ReentrantLock可以实现公平锁
ReentrantLock通过Condition可以绑定多个条件
底层实现不一样， synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略

作者：何甜甜在吗
链接：https://www.jianshu.com/p/650498242d67
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
（8）Synchronized 在 JDK1.8 之后做了哪些优化 （京东）

（9）Synchronized static 与非 static 锁的区别和范围（小米）
```
synchronized是对类的当前实例进行加锁，防止其他线程同时访问该类的该实例的所有synchronized块，注意这里是“ 类的当前实例 ”，类的两个不同实例就没有这种约束了。那么static synchronized恰好就是要控制类的所有实例的访问了，static synchronized是限制线程同时访问jvm中该类的所有实例同时访问对应的代码块。实际上，在类中某方法或某代码块中有 synchronized，那么在生成一个该类实例后，该类也就有一个监视块，放置线程并发访问该实例synchronized保护块， 而 static synchronized 则是所有该类的实例公用一个监视块了 ，也就是两个的区别了,也就是synchronized相当于this.synchronized，而staticsynchronized相当于Something.synchronized.
```
（10）volatile 关键字干了什么？（什么叫指令重排） （字节跳动）

（11）volatile 能否保证线程安全？在 DCL 上的作用是什么？

（12）volatile 和 synchronize 有什么区别？（B站 小米 京东）
```
https://blog.csdn.net/suifeng3051/article/details/52611233
```
（13）两个线程用不同的对象，怎么样？（字节跳动）

（14）什么是守护线程？你是如何退出一个线程的？

（15）sleep 、wait、yield 的区别，wait 的线程如何唤醒它？（东方头条、字节跳动）

（16）sleep 是可中断的么？（小米）

（17）实现非阻塞式生产者消费者（字节跳动）
```
使用wait notify和Arraylist实现
https://www.jianshu.com/p/e5338c638cce
```
（18）如何开启一个线程，开启大量线程会有什么问题，如何优化？（美团）
```
线程池
```

（19）线程生命周期。
```
新建状态（New）->就绪状态（Runnable）->运行状态（Running）->阻塞状态（Blocked）->死亡状态
https://www.jianshu.com/p/19228c30ffed
```
（20）ThreadLocal 是什么？
```
https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/
```
（21）AyncTask 的原理。

（22）AsyncTask 中的任务是串行的还是并行的？

（23）线程池管理线程原理。

（24）线程池的相关参数，有哪些类型的线程池，线程池任务如何调度，任务队列只是先进先出的队列吗，任务有优先级怎么办，知道优先级反转吗？ (美团)

（25）有三个线程 T1，T2，T3，怎么确保它们按顺序执行？

（26）Android 中操作多线程的方式有哪些？

（27）怎样获取当前线程是否是主线程 （字节跳动）

（28）HandlerThread 是什么？

（29）线程间如何通信？

（30）RxJava 线程切换原理，RxJava1 和 RxJava2 的区别有哪些？

## 1.4 网络编程
（1）描述 TCP 三次握手与四次挥手的过程与意义。

a.TCP 的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？

b.三次握手为什么不是两次一次 五次六次（美团）

（2）TCP 与 UDP 的区别是什么？（腾讯）

（3）Http 与 Https 的关系是什么？

（4）SSL 握手的过程。

（5）Http 的 post 与 get 请求的区别是什么？
```
GET在浏览器回退时是无害的，而POST会再次提交请求。

GET产生的URL地址可以被Bookmark，而POST不可以。

GET请求会被浏览器主动cache，而POST不会，除非手动设置。

GET请求只能进行url编码，而POST支持多种编码方式。

GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

GET请求在URL中传送的参数是有长度限制的，而POST么有。

对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

GET参数通过URL传递，POST放在Request body中。
```
（6）输入一个 URL 到浏览器发生了什么？(美团)
```
URL输入
DNS解析
TCP连接
发送HTTP请求
服务器处理请求
服务器响应请求
浏览器解析渲染页面
连接结束
```

# hashMap

[部分问题答案](https://blog.csdn.net/qq_37989738/article/details/107756260)

1. 说说你对hash算法的理解

   追问：hash算法任意长度的输入 转化为了 固定长度的输出，会不会有问题呢？

   追问：hash冲突能避免么？
2. 你认为好的hash算法，应该考虑点有哪些呢？
3. HashMap中存储数据的结构是什么样的呢？
4. 创建HashMap时，不指定散列表数组长度，初始长度是多少呢？
   追问：散列表是new HashMap() 时创建的么？
5. 默认负载因子是多少呢，并且这个负载因子有什么作用？
6. 链表转化为红黑树，需要达到什么条件呢？
7. Node对象内部的hash字段，这个hash值是key对象的hashcode()返回值么？

   追问：这个hash值是怎么得到呢？

   追问：hash字段为什么采用高低位异或？

8. HashMap put 写数据的具体流程，尽可能的详细点！
9. 红黑树的写入操作，是怎么找到父节点的，找父节点流程？
10. TreeNode数据结构，简单说下。
11. 红黑树的原则有哪些呢？
12. JDK8 hashmap为什么引入红黑树？解决什么问题？

    追问：为什么hash冲突后性能变低了？【送分题】

13. hashmap 什么情况下会触发扩容呢？

    追问：触发扩容后，会扩容多大呢？算法是什么？

    追问：为什么采用位移运算，不是直接*2？

14. hashmap扩容后，老表的数据怎么迁移到扩容后的表的呢？
15. hashmap扩容后，迁移数据发现该slot是颗红黑树，怎么处理呢？

<!-- # 二、Android 体系
（1）Acitvity 的生命周期是什么样的？a. Acitvity 的生命周期，如何摧毁一个 Activity? (美团)
（2）Activity 的 4 大启动模式，与开发中需要注意的问题，如 onNewIntent() 的调用；a. Activity 的启动模式，区别 （美团）b. singleInstance 如果不指定栈名，是怎么分配的？（字节跳动）
（3）Intent 显示跳转与隐式跳转，如何使用？（美团）
（4）Activity A 跳转 B，B 跳转 C，A 不能直接跳转到 C，A如何传递消息给 C？(美团)
（5）Activity 如何保存状态的？
（6）请描诉 Activity 的启动流程，从点击图标开始。(B站)a. APP 是怎么启动的？b. 启动一个Activity的流程分析
（7）Service 的生命周期是什么样的？a. Service 两种生命周期以及区别
（8）你会在什么情况下使用 Service？
（9）startServer 和 bindServier 的区别？(美团)
（10）Service 和 Thread 的区别？
（11）IntentService 与 Service 的区别？
（12）ContentProvider 如何自定义与使用场景是什么？
（13）BroadcastReciver 的静态注册与动态注册的区别？
（14）广播的分类与工作原理
（15）可以再 onReceive 中开启线程么，会有什么问题？
（16）什么是有序广播？
（17）Application、Activity、Service中context 的区别？能否启动一个 activity、dialog?
（18）Fragment 的生命周期？ （美团）
（19）Fragment 的构造函数为啥不让传参？（B站）
（20）Fragment add 与 replace 的区别，分别对 Fragment 的生命周期影响（美团）

三、View System
（1）View 绘制流程与自定义 View 注意点。（东方头条、美团）
Android 中的每一个UI控件都是集成自 View，然后这些 View 都具有相同的绘制流程，必须经过 measure，layout 和 draw。view 的绘制流程是在 Window 添加过程中，ViewRootImpl 类的 setView 方法开始的
（2）在 onResume 中可以测量宽高么
（3）事件分发机制是什么过程？（东方头条）
（4）冲突怎么解决？（东方头条）
（5）View 分发反向制约的方法？（字节跳动）
（6）自定义 Behavior，NestScroll，NestChild。（东方头条）
（7）View.inflater 过程与异步 inflater（东方头条）
（8）inflater 为什么比自定义 View 慢？（东方头条）
（9）onTouchListener onTouchEvent onClick 的执行顺序。（58 京东）
（10）怎么拦截事件 onTouchEvent 如果返回 false onClick 还会执行么？（58 京东）
（11）事件的分发机制，责任链模式的优缺点 （美团）
（12）动画的分类以及区别（车和家）
（13）属性动画与普通的动画有什么区别？（车和家）
（14）插值器 估值器的区别（车和家）
（15）RecyclerView 与 ListView 的对比，缓存策略，优缺点。（美团）
（16）WebView 如何做资源缓存？（字节跳动）
（17）WebView 和 JS 交互的几种方式与拦截方法。（字节跳动）
（18）自定义 view 与 viewgroup 的区别
（19）View 的绘制原理
（20）View 中 onTouch，onTouchEvent 和 onClick 的执行顺序
（21）View 的滑动方式
（22）invalidate() 和 postInvalicate() 区别
（23）View 的绘制流程是从 Activity 的哪个生命周期方法开始执行的
（24）Activity，Window，View 三者的联系和区别
（25）如何实现 Activity 窗口快速变暗
（26）ListView 卡顿的原因以及优化策略
（27）ViewHolder 为什么要被声明成静态内部类
（28）Android 中的动画有哪些? 动画占用大量内存，如何优化
（29）自定义 View 执行 invalidate()方法，为什么有时候不会回调 onDraw()
（30）DecorView， ViewRootImpl，View 之间的关系，ViewGroup.add()会多添加一个 ViewrootImpl 吗
（31）如何通过WindowManager添加Window(代码实现)？
（32）为什么Dialog不能用Application的Context？
（33）WindowMangerService中token到底是什么？有什么区别
（34）RecyclerView 是什么？如何使用？如何返回不一样的 Item
（35) RecyclerView 的回收复用机制
（36) 如何给 ListView & RecyclerView加上拉刷新 & 下拉加载更多机制
（37) 如何对 ListView & RecycleView 进行局部刷新的？
（38) ScrollView 下嵌套一个 RecycleView 通常会出现什么问题？
（39) 一个 ListView 或者一个 RecyclerView 在显示新闻数据的时候，出现图片错位，可能的原因有哪些 & 如何解决？
（40）Requestlayout，onlayout，onDraw，DrawChild 区别与联系
（41) 如何优化自定义 View
（42) Android 属性动画实现原理，补间动画实现原理

四、Android FrameWork
Android 中多进程通信的方式有哪些？a.进程通信你用过哪些？原理是什么？（字节跳动、小米）
描述下 Binder 机制原理？（东方头条）
Binder 线程池的工作过程是什么样？（东方头条）
Handler 怎么进行线程通信，原理是什么？（东方头条）
Handler 如果没有消息处理是阻塞的还是非阻塞的？（字节跳动、小米）
handler.post(Runnable) runnable 是如何执行的？（字节跳动、小米）
handler 的 Callback 和 handlemessage 都存在，但 callback 返回 true handleMessage 还会执行么？（字节跳动、小米）
Handler 的 sendMessage 和 postDelay 的区别？（字节跳动）
IdleHandler 是什么？怎么使用，能解决什么问题？
为什么 Looper.loop 不阻塞主线程？a.Looper 无限循环为啥没有 ANR（B站）
Looper 如何在子线程中创建？（字节跳动、小米）
Looper、handler、线程间的关系。例如一个线程可以有几个 Looper 可以对应几个 Handler？（字节跳动、小米）
如何更新 UI，为什么子线程不能更新 UI？(美团)
ThreadLocal 的原理，以及在 Looper 是如何应用的？（字节跳动、小米）
Android 有哪些存储数据的方式？
SharedPreference 原理，commit 与 apply 的区别是什么？使用时需要有哪些注意？
如何判断一个 APP 在前台还是后台？
如何做应用保活？
一张图片 100x100 在内存中的大小？（字节跳动）
Intent的 原理，作用，可以传递哪些类型的参数?
如果需要在 Activity 间传递大量的数据怎么办？
打开多个页面，如何实现一键退出?
LiveData 的生命周期如何监听的?(B站)
五、性能优化专题
App 稳定性优化
App 启动速度优化
App 内存优化
App 绘制优化
App 瘦身
网络优化
App 电量优化
安卓的安全优化
为什么 WebView 加载会慢呢？
如何优化自定义 View
FC(Force Close)什么时候会出现？
Java 多线程引发的性能问题，怎么解决？
TraceView 的实现原理，分析数据误差来源。
是否使用过 SysTrace，原理的了解？
mmap + native 日志优化？
六、三方源码理解
Glide ：加载、缓存、LRU 算法 (如何自己设计一个大图加载框架) （LRUCache 原理）
EventBus
LeakCanary
ARouter
插件化（不同插件化机制原理与流派，优缺点。局限性）
热修复
RXJava （RxJava 的线程切换原理）
Retrofit （Retrofit 在 OkHttp 上做了哪些封装？动态代理和静态代理的区别，是怎么实现的）
OkHttp -->
```
作者：木木
链接：https://leetcode-cn.com/circle/discuss/5szs6p/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```
[以下部分原文](https://juejin.cn/post/6844903895123099662)

### 1.什么情况下会发生栈内存溢出。

**思路：** 描述栈定义，再描述为什么会溢出，再说明一下相关配置参数，OK的话可以给面试官手写是一个栈溢出的demo。

**我的答案：**

- 栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型
- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，方法递归调用产生这种结果。
- 如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将抛出一个OutOfMemory 异常。(线程启动过多)
- 参数 -Xss 去调整JVM栈的大小

### 2.详解JVM内存模型

**思路：** 给面试官画一下JVM内存模型图，并描述每个模块的定义，作用，以及可能会存在的问题，如栈溢出等。

**我的答案：**

- JVM内存结构



![img](https://user-gold-cdn.xitu.io/2019/7/22/16c1a426ed9ab48b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



程序计数器：当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有。

Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有。

Native方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有。

Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享。

方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享

### 3.JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。

**思路：** 先讲一下JAVA堆，新生代的划分，再谈谈它们之间的转化，相互之间一些参数的配置（如： –XX:NewRatio，–XX:SurvivorRatio等），再解释为什么要这样划分，最好加一点自己的理解。

**我的答案：**

#### 1）共享内存区划分

- 共享内存区 = 持久带 + 堆
- 持久带 = 方法区 + 其他
- Java堆 = 老年代 + 新生代
- 新生代 = Eden + S0 + S1

#### 2）一些参数的配置

- 默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置。
- 默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定)
- Survivor区中的对象被复制次数为15(对应虚拟机参数 -XX:+MaxTenuringThreshold)

#### 3)为什么要分为Eden和Survivor?为什么要设置两个Survivor区？

- 如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。
- Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
- 设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）

### 4. JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代

**思路：** 先描述一下Java堆内存划分，再解释Minor GC，Major GC，full GC，描述它们之间转化流程。

**我的答案：**

- Java堆 = 老年代 + 新生代
- 新生代 = Eden + S0 + S1
- 当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。
- **大对象**（需要大量连续内存空间的Java对象，如那种很长的字符串）**直接进入老年态**；
- 如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，**若年龄超过一定限制（15），则被晋升到老年态**。即**长期存活的对象进入老年态**。
- 老年代满了而**无法容纳更多的对象**，Minor GC 之后通常就会进行Full GC，Full GC  清理整个内存堆 – **包括年轻代和年老代**。
- Major GC **发生在老年代的GC**，**清理老年区**，经常会伴随至少一次Minor GC，**比Minor GC慢10倍以上**。

### 5.你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。

**思路：** 一定要记住典型的垃圾收集器，尤其cms和G1，它们的原理与区别，涉及的垃圾回收算法。

**我的答案：**

#### 1）几种垃圾收集器：

- **Serial收集器：** 单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。
- **ParNew收集器：**  Serial收集器的多线程版本，也需要stop the world，复制算法。
- **Parallel Scavenge收集器：** 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。
- **Serial Old收集器：** 是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。
- **Parallel Old收集器：** 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。
- **CMS(Concurrent Mark Sweep) 收集器：** 是一种以获得最短回收停顿时间为目标的收集器，**标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除**，收集结束会产生大量空间碎片。
- **G1收集器：** 标记整理算法实现，**运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记**。不会产生空间碎片，可以精确地控制停顿。

#### 2）CMS收集器和G1收集器的区别：

- CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；
- G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
- CMS收集器以最小的停顿时间为目标的收集器；
- G1收集器可预测垃圾回收的停顿时间
- CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
- G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

### 6.JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。

**思路：**  先画出Java内存模型图，结合例子volatile ，说明什么是重排序，内存屏障，最好能给面试官写以下demo说明。

**我的答案：**

#### 1）Java内存模型图：



![img](https://user-gold-cdn.xitu.io/2019/7/23/16c1c1982e3609b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



Java内存模型规定了所有的**变量都存储在主内存**中，每条**线程还有自己的工作内存**，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，**线程对变量的所有操作都必须在工作内存中**进行，**而不能直接读写主内存**。不同的线程之间也**无法直接访问对方工作内存中的变量**，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

#### 2）指令重排序。

在这里，先看一段代码

```
public class PossibleReordering {
static int x = 0, y = 0;
static int a = 0, b = 0;

public static void main(String[] args) throws InterruptedException {
    Thread one = new Thread(new Runnable() {
        public void run() {
            a = 1;
            x = b;
        }
    });

    Thread other = new Thread(new Runnable() {
        public void run() {
            b = 1;
            y = a;
        }
    });
    one.start();other.start();
    one.join();other.join();
    System.out.println(“(” + x + “,” + y + “)”);
}
复制代码
```

运行结果可能为(1,0)、(0,1)或(1,1)，也可能是(0,0)。因为，在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。通过乱序执行的技术，处理器可以大大提高执行效率。而这就是**指令重排**。

#### 3）内存屏障

**内存屏障**，也叫内存栅栏，是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。

- **LoadLoad屏障**：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
- **StoreStore屏障**：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
- **LoadStore屏障**：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
- **StoreLoad屏障**：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。        在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。

#### 4）happen-before原则

- **单线程happen-before原则**：在同一个线程中，书写在前面的操作happen-before后面的操作。 锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。
- **volatile的happen-before原则**：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。
- **happen-before的传递性原则**：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。
- **线程启动的happen-before原则**：同一个线程的start方法happen-before此线程的其它方法。
- **线程中断的happen-before原则** ：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。
- **线程终结的happen-before原则：** 线程中的所有操作都happen-before线程的终止检测。
- **对象创建的happen-before原则：** 一个对象的初始化完成先于他的finalize方法调用。

### 7.简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。

**思路：** 先说明一下什么是类加载器，可以给面试官画个图，再说一下类加载器存在的意义，说一下双亲委派模型，最后阐述怎么打破双亲委派模型。

**我的答案：**

#### 1) 什么是类加载器？

**类加载器** 就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。

> - 启动类加载器（Bootstrap  ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。
> - 其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：
>
> > - 扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。
> > - 应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

#### 2）双亲委派模型

**双亲委派模型工作过程是：**

> 如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。

双亲委派模型图：



![img](https://user-gold-cdn.xitu.io/2019/7/23/16c1c54cf4ad886b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



#### 3）为什么需要双亲委派模型？

在这里，先想一下，如果没有双亲委派，那么用户是不是可以**自己定义一个java.lang.Object的同名类**，**java.lang.String的同名类**，并把它放到ClassPath中,那么**类之间的比较结果及类的唯一性将无法保证**，因此，为什么需要双亲委派模型？**防止内存中出现多份同样的字节码**

#### 4）怎么打破双亲委派模型？

打破双亲委派机制则不仅**要继承ClassLoader**类，还要**重写loadClass和findClass**方法。

### 8.说说你知道的几种主要的JVM参数

**思路：** 可以说一下堆栈配置相关的，垃圾收集器相关的，还有一下辅助信息相关的。

**我的答案：**

#### 1）堆栈配置相关

```
java -Xmx3550m -Xms3550m -Xmn2g -Xss128k 
-XX:MaxPermSize=16m -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxTenuringThreshold=0
复制代码
```

**-Xmx3550m：** 最大堆大小为3550m。

**-Xms3550m：** 设置初始堆大小为3550m。

**-Xmn2g：** 设置年轻代大小为2g。

**-Xss128k：** 每个线程的堆栈大小为128k。

**-XX:MaxPermSize：**  设置持久代大小为16m

**-XX:NewRatio=4:** 设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。

**-XX:SurvivorRatio=4：** 设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6

**-XX:MaxTenuringThreshold=0：** 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。

#### 2）垃圾收集器相关

```
-XX:+UseParallelGC
-XX:ParallelGCThreads=20
-XX:+UseConcMarkSweepGC 
-XX:CMSFullGCsBeforeCompaction=5
-XX:+UseCMSCompactAtFullCollection：
复制代码
```

**-XX:+UseParallelGC：** 选择垃圾收集器为并行收集器。

**-XX:ParallelGCThreads=20：** 配置并行收集器的线程数

**-XX:+UseConcMarkSweepGC：** 设置年老代为并发收集。

**-XX:CMSFullGCsBeforeCompaction**：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。

**-XX:+UseCMSCompactAtFullCollection：** 打开对年老代的压缩。可能会影响性能，但是可以消除碎片

#### 3）辅助信息相关

```
-XX:+PrintGC
-XX:+PrintGCDetails
复制代码
```

**-XX:+PrintGC 输出形式:**

[GC 118250K->113543K(130112K), 0.0094143 secs] [Full GC 121376K->10414K(130112K), 0.0650971 secs]

**-XX:+PrintGCDetails 输出形式:**

[GC [DefNew: 8614K->781K(9088K), 0.0123035 secs] 118250K->113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K->8614K(9088K), 0.0000665 secs][Tenured: 112761K->10414K(121024K), 0.0433488 secs] 121376K->10414K(130112K), 0.0436268 secs

### 9.怎么打出线程栈信息。

**思路：** 可以说一下jps，top ，jstack这几个命令，再配合一次排查线上问题进行解答。

**我的答案：**

- 输入jps，获得进程号。
- top -Hp pid 获取本进程中所有线程的CPU耗时性能
- jstack pid命令查看当前java进程的堆栈状态
- 或者 jstack -l  > /tmp/output.txt 把堆栈信息打到一个txt文件。
- 可以使用fastthread 堆栈定位，[fastthread.io/](http://fastthread.io/)

### 10.强引用、软引用、弱引用、虚引用的区别？

**思路：** 先说一下四种引用的定义，可以结合代码讲一下，也可以扩展谈到ThreadLocalMap里弱引用用处。

**我的答案：**

#### 1）强引用

我们平时new了一个对象就是强引用，例如 Object obj = new Object();即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。

#### 2）软引用

如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。

```
SoftReference<String> softRef=new SoftReference<String>(str);     // 软引用
复制代码
```

**用处：** 软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。

（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建

（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出

如下代码：

```
Browser prev = new Browser();               // 获取页面进行浏览
SoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用        
if(sr.get()!=null){ 
    rev = (Browser) sr.get();           // 还没有被回收器回收，直接获取
}else{
    prev = new Browser();               // 由于内存吃紧，所以对软引用的对象回收了
    sr = new SoftReference(prev);       // 重新构建
}
复制代码
```

#### 3）弱引用

具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

```
String str=new String("abc");    
WeakReference<String> abcWeakRef = new WeakReference<String>(str);
str=null;
等价于
str = null;
System.gc();
复制代码
```

#### 4）虚引用

如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。

### 11.待更新

### 參考与感谢

- 为什么新生代内存需要有两个Survivor区 [blog.csdn.net/antony9118/…](https://blog.csdn.net/antony9118/article/details/51425581)
- JVM内存模型、指令重排、内存屏障概念解析：[www.cnblogs.com/chenyangyao…](https://www.cnblogs.com/chenyangyao/p/5269622.html)
- java 8大happen-before原则超全面详解 [www.jianshu.com/p/1508eedba…](https://www.jianshu.com/p/1508eedba54d)
- JVM参数配置大全 [www.cnblogs.com/edwardlauxh…](https://www.cnblogs.com/edwardlauxh/archive/2010/04/25/1918603.html)
- Java 的强引用、弱引用、软引用、虚引用 [www.cnblogs.com/gudi/p/6403…](https://www.cnblogs.com/gudi/p/6403953.html)
- 《深入理解Java虚拟机》


作者：捡田螺的小男孩
链接：https://juejin.cn/post/6844903895123099662
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。