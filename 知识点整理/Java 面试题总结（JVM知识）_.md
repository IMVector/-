 Java 面试题总结（JVM知识）

## 1.操作系统中 heap 和 stack 的区别？

栈(stack)与堆(heap)都是Java用来在内存中存放数据的地方。
 与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 

在方法中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。
 当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 

堆内存用来存放由new创建的对象和数组，
 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。
 在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。
 引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。 
 Java中变量在内存中的分配： 
 　1、类变量（static修饰的变量）：在程序加载时系统就为它在堆中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期–一直持续到整个”系统”关闭。 
 　2、实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量（比如说类实例），然后根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”。 
 　  实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存。 
 　3、局部变量：局部变量，由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放。 

 

## 2.什么情况下会发生栈内存溢出？

栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化）

所以我们可以理解为栈溢出就是方法执行时创建的栈帧超过了栈的深度。那么最有可能的就是方法递归调用产生这种结果。

```java
public class JvmTest {
	private int i = 0;
	public void a(){
		System.out.println(i++);
		a();
	}
	public static void main(String[] args) {
		JvmTest j = new JvmTest();
		j.a();
	}
}
```

输出结果：

![img](https://img.javatt.com/c8/c8f550d395dfcb6fdd43a2804a2024b4.png)

如何解决：

我们需要使用参数 -Xss 去调整JVM栈的大小

![img](https://img.javatt.com/be/be4211d6fe08bddfe76003d084f046f8.png)

解决后效果如下：

![img](https://img.javatt.com/d7/d748e0659fdd5e5bcc246e80b995500f.png)

 

## 2.什么情况下会发生堆溢出？

heap space表示堆空间，堆中主要存储的是对象。如果不断的new对象则会导致堆中的空间溢出：

```java
public class JvmTest {
	public static void main(String[] args) {
		List<String> aList = new ArrayList<String>();
		try{
			while(true){
				aList.add("asdasdasdas");
			}
		}catch(Throwable e){
			System.out.println(aList.size());
			e.printStackTrace();
		}
	}
}
```

异常信息：

![img](https://img.javatt.com/bd/bda547290917397d5497f3d96ac0141e.png)

可以通过 -Xmx4096M 调整堆的总大小。

 

## 3.JVM的内存结构，Eden和Survivor比例？

先看一张图，这张图能很清晰的说明JVM内存结构布局：

![img](https://img.javatt.com/f3/f3968de639953418484dfb8d3fba3ddf.png)

![JUtH_20121024_RuntimeDataAreas_6_MemoryModel](https://img.javatt.com/a8/a87faa872e41f9de5330cb1c8c413927.png)

![这里写图片描述](https://img.javatt.com/be/be32fa804c0480b85a54faadbcd75b70.png)

JVM内存结构主要有三大块：**堆内存**、**方法区**和**栈**。

**堆内存**是JVM中最大的一块由**年轻代**和**老年代**组成，而年轻代内存又被分成三部分，**Eden空间**、**From Survivor空间**、**To Survivor空间，**默认情况下年轻代按照8:1:1的比例来分配。

**方法区**存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)。

**栈**又分为java虚拟机栈和本地方法栈主要用于方法的执行。

在通过一张图来了解如何通过参数来控制各区域的内存大小：

![jvm_m_l](https://img.javatt.com/78/78f8eb4e67f1bf3d93cfd257be090683.png)

 

***\*控\*******\*制参数\****
-Xms：设置堆的最小空间大小。

-Xmx：设置堆的最大空间大小。

-XX:NewSize：设置新生代最小空间大小。

-XX:MaxNewSize：设置新生代最大空间大小。

-XX:PermSize：设置永久代最小空间大小。

-XX:MaxPermSize：设置永久代最大空间大小。

-Xss：设置每个线程的堆栈大小。

没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制：

***\*老年代空间大小=堆空间大小-年轻代大空间大小\****

从更高的一个维度再次来看JVM和系统调用之间的关系：

![002hLfJYgy71J9KxlH53b](https://img.javatt.com/10/10ffdb75c5cecded53db7a22b5b6e6cc.png)

方法区和堆是所有线程共享的内存区域，而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。

**下面我们详细介绍每个区域的作用**

 

***\*Java\*******\*堆（Heap）\****

  对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中***\*最大\****的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，***\*几乎所有的对象实例都在这里分配内存。\****

   Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“***\*GC堆\****”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：***\*新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。\****

根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。

如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

***\**\*\*\*方法区（Method Area）\*\*\*\*\****

 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，***\*它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据\****。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。

对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。

Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。

根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 

***\**\*\*\*程序计数器（Program Counter Register）\*\*\*\*\****

程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 
由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 
   如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。

***\*此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。\****

***\**\*\*\*JVM栈（JVM Stacks）\*\*\*\*\****

与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，**它的生命周期与线程相同**。**虚拟机栈描述的是Java方法执行的内存模型**：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。**每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程**。 

局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。

其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出***\*StackOverflowError\****异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出***\*OutOfMemoryError\****异常。

 

***\**\*\*\*本地方法栈（Native Method Stacks）\*\*\*\*\****

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而**本地方法栈则是为虚拟机使用到的Native方法服务**。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

 

## 4.JVM内存为什么要分成新生代，老年代，持久代？新生代中为什么要分为Eden和Survivor？

虚拟机中的共划分为三个代：年轻代（Young Generation）、老年代（Old Generation）和持久代（Permanent Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。

**年轻代:**

所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor区过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。

**老年代:**

在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中。因此，可以认为老年代中存放的都是一些生命周期较长的对象。

**持久代:**

用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=<N>进行设置。

**注意：**

**堆=新生代+老年代，不包括永久代（方法区）。**

 

**Scavenge GC**

一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。

**Full GC**

对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：

· 老年代（Tenured）被写满

· 持久代（Perm）被写满

· System.gc()被显示调用

·上一次GC之后Heap的各域分配策略动态变化

JVM内存参数

**-vmargs -Xms128M -Xmx512M -XX:PermSize=64M -XX:MaxPermSize=128M
 -vmargs 说明后面是VM的参数，所以后面的其实都是JVM的参数了
 -Xms128m JVM初始分配的堆内存
 -Xmx512m JVM最大允许分配的堆内存，按需分配
 -XX:PermSize=64M JVM初始分配的非堆内存
 -XX:MaxPermSize=128M JVM最大允许分配的非堆内存，按需分配**

**堆(Heap)和非堆(Non-heap)内存**

按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”

“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。
 可以看出JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给自己用的。

[新生代](https://www.baidu.com/s?wd=新生代&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)分为三个区域，一个Eden区和两个Survivor区，它们之间的比例为（8：1：1），这个比例也是可以修改的。

通常情况下，对象主要分配在新生代的Eden区上，少数情况下也可能会直接分配在老年代中。Java虚拟机每次使用新生代中的Eden和其中一块Survivor（From），在经过一次Minor GC后，将Eden和Survivor中还存活的对象一次性地复制到另一块Survivor空间上（这里使用的复制算法进行GC），最后清理掉Eden和刚才用过的Survivor（From）空间。将此时在Survivor空间存活下来的对象的年龄设置为1，以后这些对象每在Survivor区熬过一次GC，它们的年龄就加1，当对象年龄达到某个年龄（默认值为15）时，就会把它们移到老年代中。在新生代中进行GC时，有可能遇到另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。

**1.Eden区**

  Eden区位于Java堆的年轻代，是新对象分配内存的地方，由于堆是所有线程共享的，因此在堆上分配内存需要加锁。而Sun JDK为提升效率，会为每个新建的线程在Eden上分配一块独立的空间由该线程独享，这块空间称为TLAB（Thread Local Allocation Buffer）。在TLAB上分配内存不需要加锁，因此JVM在给线程中的对象分配内存时会尽量在TLAB上分配。如果对象过大或TLAB用完，则仍然在堆上进行分配。如果Eden区内存也用完了，则会进行一次Minor GC（young GC）。

**2.Survival from to**

  Survival区与Eden区相同都在Java堆的年轻代。Survival区有两块，一块称为from区，另一块为to区，这两个区是相对的，在发生一次Minor GC后，from区就会和to区互换。在发生Minor GC时，Eden区和Survival from区会把一些仍然存活的对象复制进Survival to区，并清除内存。Survival to区会把一些存活得足够旧的对象移至年老代。

**总结：**

1、Minor GC是发生在新生代中的垃圾收集，采用的复制算法；

2、新生代中每次使用的空间不超过90%，主要用来存放新生的对象；

3、Minor GC每次收集后Eden区和一块Survivor区都被清空；

4、老年代中使用Full GC，采用的标记-清除算法。

 

## 5.JVM中一次完整的GC流程是怎样的？对象如何晋升到老年代？说说你知道的几种主要的JVM参数？

完成的GC流程：

![img](https://img.javatt.com/f5/f5246db687ee1df57ff4baae8c9665a9.png)

对于整个的GC流程里面，那么最需要处理的就是年轻代与老年代的内存清理操作，而元空间（永久代）都不在GC范围内。

- 当现在有一个新的对象产生，那么对象一定需要内存空间，于是现在就需要为该对象进行内存空间的申请；
- 首先会判断Eden区是否有内存空间，如果此时有内存空间，则直接将新对象保存在Eden区；
- 但是如果此时Eden区的内存空间不足，那么会自动执行一个Minor GC操作，将Eden区的无用内存空间进行清理，清理之后会继续判断Eden区的内存空间是否充足，如果内存空间充足，则将新的对象直接在伊甸园区进行空间分配； 
- 如果执行了Minor GC之后发现Eden区的内存依然不足，那么这个时候会进行Survivor区判断，如果Survivor区有剩余空间，则将Eden区的部分活跃对象保存在Survivor区，那么随后继续判断Eden区的内存空间是否充足，如果充足，则在Eden区进行新对象的空间分配；
- 如果此时Survivor区也已经没有内存空间了，则继续判断老年区，如果此时老年区空间充足，则将存活区中的活跃对象保存到老年代，而后Survivor区就会存现有空余空间，随后Eden区将活跃对象保存在Survivor区之中，而后在Eden区里为新对象开辟空间；
- 如果这个时候老年代也满了，那么这个时候将产生Major GC（Full GC），进行老年代的内存清理。
- 如果老年代执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”

**几种主要的JVM参数：**

![img](https://img.javatt.com/6f/6f7eb8e4f3c9bfa6aad6a410b43c5d87.png)

 

## 6.你知道哪几种垃圾收集器？各自的优缺点？重点讲下cms和G1？包括原理，流程，优缺点？

**1. Serial收集器**

Serial收集器是JAVA虚拟机中最基本、历史最悠久的收集器，在JDK 1.3.1之前是JAVA虚拟机[新生代](https://www.baidu.com/s?wd=新生代&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)收集的唯一选择。Serial收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。

Serial收集器到JDK 1.7为止，它依然是JAVA虚拟机运行在Client模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。

PS：开启Serial收集器的方式 -XX:+UseSerialGC

如：Xms30m -Xmx30m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails

-XX:+UseSerialGC的是Serial收集器，Xms30m -Xmx30m 指定了JAVA虚拟机的固定大小为30M，-Xmn10m 指JAVA新生代的空间为10M。

 

**2. Parallel（并行）收集器**

这是 JVM 的缺省收集器。就像它的名字，其最大的优点是使用多个线程来通过扫描并压缩堆。串行收集器在GC时会停止其他所有工作线程（stop-the-world），CPU利用率是最高的，所以适用于要求高吞吐量（throughput）的应用，但停顿时间（pause time）会比较长，所以对web应用来说就不适合，因为这意味着用户等待时间会加长。而并行收集器可以理解是多线程串行收集，在串行收集基础上采用多线程方式进行GC，很好的弥补了串行收集的不足，可以大幅缩短停顿时间（如下图表示的停顿时长高度，并发比并行要短），因此对于空间不大的区域（如young generation），采用并行收集器停顿时间很短，回收效率高，适合高频率执行。

 

**3.CMS收集器**

CMS（Concurrent Mark Sweep）收集器是基于“标记-清除”算法实现的，它使用多线程的算法去扫描堆（标记）并对发现的未使用的对象进行回收（清除）。整个过程分为6个步骤，包括：

初始标记（CMS initial mark）

并发标记（CMS concurrent mark）

并发预清理（CMS-concurrent-preclean）

重新标记（CMS remark）

并发清除（CMS concurrent sweep）

并发重置（CMS-concurrent-reset）

其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。其他动作都是并发的。

需要注意的是，CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将其清理掉。这一部分垃圾就称为“浮动垃圾”。是由于在垃圾收集阶段用户线程还需要运行，即还需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-X:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数以获取更好的性能。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置得太高将会很容易导致大量“Concurrent Mode Failure”失败，性能反而降低。

还有一个缺点，CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会产生大量空间碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费附送一个碎片整理过程，[内存整理](https://www.baidu.com/s?wd=内存整理&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者们还提供了另外一个参数-XX: CMSFullGCsBeforeCompaction，这个参数用于设置在执行多少次不压缩的Full GC后，跟着来一次带压缩的。

该算法与并行收集器的另一个缺点是高吞吐量的它使用更多的 CPU，为了使应用程序提供更好的体验，通过使用多个线程来执行扫描和收集。这种情况长时间的运行会使应用程序停顿下来，可以使用提高空间来换取高效的运行。但是，这种算法的使用不是默认的。您必须指定 XX： + USeParNewGC来使用它。如果你可以提供更多的CPU资源的话以避免应用程序暂停，那么你可以使用CMS收集器。假设你的堆的大小小于 4 Gb你必须分配大于 4 GB的资源。

 

**4.G1收集器**

G1垃圾收集器在JDK7 update 4之后对大于4G的堆有了更好的支持，G1是一个针对多处理器大容量内存的服务器端的垃圾收集器，其目标是在实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的要求。G1在执行一些Java堆空间中的全区域操作（如：全局标记）时是和应用程序线程并发进行的，因此减少了Java堆空间的中断比例。（译者注：可简单理解为减少了Stop-the-World的时间比例）。

它与前面的CMS收集器相比有两个显著的改进：一是G1收集器是基于“标记-整理”算法实现的收集器，也就是说它不会产生空间碎片，这对于长时间运行的应用系统来说非常重要。二是它可以非常精确地控制停顿，既能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，具备了一些实时Java（RTSJ）的垃圾收集器的特征。

首先将Java堆空间划分为一些大小相等的区域（region），每个区域都是虚拟机中的一段连续内存空间。G1通过执行并发的全局标记来确定整个Java堆空间中存活的对象。标记阶段完成后，G1就知道哪些区域基本上是空闲的。在回收内存时优先回收这些区域，这样通常都会回收相当数量的内存。这就是为什么它叫做Garbage-First的原因。[顾名思义](https://www.baidu.com/s?wd=顾名思义&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)G1关注某些区域的回收和整理，这些区域中的对象很有可能被完全回收。而且G1使用了一个暂停时间预测模型使得暂停时间控制在用户指定的暂停时间内，并根据用户指定的暂停时间来选择合适的区域回收内存。

G1确定了可回收的区域后就是筛选回收（evacuation）阶段了。在此阶段将对象从一个或多个区域复制到单一区域，同时整理和释放内存。该阶段是在多个处理器上多个线程并行进行的，因此减少了暂停时间并提高了吞吐量。G1在每一次的垃圾收集过程中都不断地减少碎片，并能够将暂停时间控制在一定范围内。这些已经是以前的垃圾收集器无法完成的了。比如：CMS收集器并不做内存整理。ParallelOld收集器只是对整个Java堆空间做整理，这样导致相当长的暂停时间。

 

**Java8对G1收集器的优化**

在java8 udpate 20中对G1收集器采用了字符串重复消除技术（String deduplication），之前字符串以及内部的char[]数组大量消耗了内存空间，在新的G1垃圾收集器中，将会对内存中重复的字符串进行优化，使他们指向同一个字符数组，以避免相同的字符串出现而使堆处理效率低下，你可以使用 -XX:+UseStringDeduplicationJVM参数来开启。

 

**Java8和PermGen**

在 Java 8 最大的变化之一删除了在堆中为类的元数据、内部字符串和静态变量分配 permgen空间的部分。过去如果加载大量的类到内存中经常会出现内存溢出异常，并且开发人员需要在这个方面做大量的工作，所以如果这段通过JVM来管理了将是一个不错误的优化。

 

每个垃圾收集器都有不同的配置参数，可以通过不同的参数来提升性能和降低吞吐量。这些都取决于你的应用需求，不同的对收集方式、可忍受的停顿时间、内存的大小都不一样，所以要根据自身的需求来定制不同的配置参数。

 

## 7.垃圾回收算法的实现原理？

**1.引用计数法**

引用计数器的实现很简单，对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就+1，当引用时效时，引用计数器就-1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用。

注：因为无法处理循环引用的情况，因此，在Java的垃圾回收器中没有使用这种算法。

如：有对象A和对象B，对象A中含有对象B的引用，对象B中含有对象A的引用。

**2.标记-清除**

标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。

![img](https://img.javatt.com/bc/bc751f0c169695e9b8440e6d0e866612.png)

**3.标记-整理**

标记-整理算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法首先也需要从根节点开始，对所有可达对象做一次标记。但之后，它并不简单地清除未被标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外的所有空间。

![img](https://img.javatt.com/3d/3d67d4489e1f700ce7c0796b0fa89f54.png)

**4.复制算法**

与标记-清除算法相比，复制算法是一种相对高效的回收方法。

不适用于存活对象较多的场合，如老年代。

将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。

![img](https://img.javatt.com/1f/1fbcd3dd4b2574233c6dbdb5443cfaf4.png)

**5.分代思想**

依据对象的存活周期进行分类，短命对象归为新生代，长命对象归为老年代。

 

**总结：**

依据不同代的特点，选取合适的收集算法。

- 少量对象存活，适合复制算法。
- 大量对象存活，适合标记-清理或者标记-压缩。

 

## 8.当出现了内存溢出，你怎么排错？

1.首先控制台查看错误日志

2.然后使用jdk自带的jvisualvm工具查看系统的堆栈日志

3.定位出内存溢出的空间：堆，栈还是永久代（jdk8以后不会出现永久代的内存溢出）。

4.如果是堆内存溢出，看是否创建了超大的对象

5.如果是栈内存溢出，看是否创建了超大的对象，或者产生了死循环。

## 9.JVM内存模型的相关知识了解多少？比如重排序，内存屏障，happen-before，主内存，工作内存等？

重排序：JVM虚拟机允许在不影响代码最终结果的情况下，可以乱序执行。

内存屏障：可以阻挡编译器的优化，也可以阻挡处理器的优化。

happens-before原则：

1、一个线程的A操作总是在B之前，那多线程的A操作肯定是在B之前。

2、Monitor再加锁的情况下，持有锁的肯定先执行。

3、volatile修饰的情况下，写先于读发生。

4、线程启动在一切之前 strat。

5、线程死亡在一切之后 end。

6、线程操作在一切线程中断之前。

7、一个对象构造函数的结束都在该对象的finalizer的开始之前。

8、传递性，如果A肯定在B之前，B肯定在C之前，那A肯定是在C之前。

主内存：所有线程共享的内存空间。

工作内存：每个线程特有的内存空间。

## 10.简单说说你了解的类加载器，可以打破双亲委派么？怎么打破？

首先，先要知道什么是类加载器。简单说，类加载器就是根据指定全限定名称将`class`文件加载到`JVM`内存，转为`Class`对象。如果站在`JVM`的角度来看，只存在两种类加载器：

启动类加载器（`Bootstrap ClassLoader`）：由`C++`语言实现（针对`HotSpot`）,负责将存放在`<JAVA_HOME>\lib`目录或`-Xbootclasspath`参数指定的路径中的类库加载到内存中。

其他类加载器：由`Java`语言实现，继承自抽象类`ClassLoader`。如：

- 扩展类加载器（`Extension ClassLoader`）：负责加载`<JAVA_HOME>\lib\ext`目录或`java.ext.dirs`系统变量指定的路径中的所有类库。
- 应用程序类加载器（`Application ClassLoader`）：负责加载用户类路径（`classpath`）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

 

双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即`ClassNotFoundException`），子加载器才会尝试自己去加载。

为什么需要双亲委派模型呢？假设没有双亲委派模型，试想一个场景：

黑客自定义一个`java.lang.String`类，该`String`类具有系统的`String`类一样的功能，只是在某个函数稍作修改。比如`equals`函数，这个函数经常使用，如果在这这个函数中，黑客加入一些“病毒代码”。并且通过自定义类加载器加入到`JVM`中。此时，如果没有双亲委派模型，那么`JVM`就可能误以为黑客自定义的`java.lang.String`类是系统的`String`类，导致“病毒代码”被执行。

而有了双亲委派模型，黑客自定义的`java.lang.String`类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的`java.lang.String`类，最终自定义的类加载器无法加载`java.lang.String`类。

或许你会想，我在自定义的类加载器里面强制加载自定义的`java.lang.String`类，不去通过调用父加载器不就好了吗？确实，这样是可行。但是，在`JVM`中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false。

举个简单例子：

`ClassLoader1`、`ClassLoader2`都加载`java.lang.String`类，对应Class1、Class2对象。那么`Class1`对象不属于`ClassLoad2`对象加载的`java.lang.String`类型。

打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法，如下例子：

①定义Test类：

```java
public class Test {
  public Test(){
    System.out.println(this.getClass().getClassLoader().toString());
  }
}
```

②重新定义一个继承ClassLoader的TestClassLoaderN类，这个类与前面的TestClassLoader类很相似，但它除了重写findClass方法外还重写了loadClass方法，默认的loadClass方法是实现了双亲委派机制的逻辑，即会先让父类加载器加载，当无法加载时才由自己加载。这里为了破坏双亲委派机制必须重写loadClass方法，即这里先尝试交由System类加载器加载，加载失败才会由自己加载。它并没有优先交给父类加载器，这就打破了双亲委派机制。

```java
public class TestClassLoaderN extends ClassLoader {
 
  private String name;
 
  public TestClassLoaderN(ClassLoader parent, String name) {
    super(parent);
    this.name = name;
  }
 
  @Override
  public String toString() {
    return this.name;
  }
 
  @Override
  public Class<?> loadClass(String name) throws ClassNotFoundException {
    Class<?> clazz = ;
    ClassLoader system = getSystemClassLoader();
    try {
      clazz = system.loadClass(name);
    } catch (Exception e) {
      // ignore
    }
    if (clazz != )
      return clazz;
    clazz = findClass(name);
    return clazz;
  }
 
  @Override
  public Class<?> findClass(String name) {
 
    InputStream is = ;
    byte[] data = ;
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    try {
      is = new FileInputStream(new File("d:/Test.class"));
      int c = 0;
      while (-1 != (c = is.read())) {
        baos.write(c);
      }
      data = baos.toByteArray();
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      try {
        is.close();
        baos.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    return this.defineClass(name, data, 0, data.length);
  }
 
  public static void main(String[] args) {
    TestClassLoaderN loader = new TestClassLoaderN(
        TestClassLoaderN.class.getClassLoader(), "TestLoaderN");
    Class clazz;
    try {
      clazz = loader.loadClass("test.classloader.Test");
      Object object = clazz.newInstance();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
 
}
```

 

## 11.讲讲JAVA的反射机制？

在运行状态中，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。通俗点讲，通过反射，该类对我们来说是完全透明的，想要获取任何东西都可以。

 

## 12.你们线上应用的JVM参数有哪些？

 

## 13.g1和cms区别，吞吐量优先和响应优先的垃圾收集器选择？

CMS收集器：一款以获取最短回收停顿时间为目标的收集器，是基于“标记-清除”算法实现的，分为4个步骤：初始标记、并发标记、重新标记、并发清除。 

G1收集器：面向服务端应用的垃圾收集器，过程：初始标记；并发标记；最终标记；筛选回收。整体上看是“标记-整理”，局部看是“复制”，不会产生内存碎片。 

吞吐量优先的并行收集器：以到达一定的吞吐量为目标，适用于科学技术和后台处理等。 
 响应时间优先的并发收集器：保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。

 

## 14.怎么打出线程栈信息？

第一步：在终端运行Java程序。

第二步：通过命令 pidof java 找到已经启动的java进程的ID，选择需要查看的java程序的进程ID。

第三步：使用命令 kill -3 (java进行的pid) 打印出java程序的线程堆栈信息。

第四步：通常情况下运行的项目可能会比较大，那么这个时候打印的堆栈信息可能会有几千到几万行，为了方便查看，我们往往需要将输出内容进行重定向。使用linux下的重定向命令方式即可：例如： demo.sh > run.log 2>&1 将输出信息重定向到 run.log中。

注：在操作系统中，0 1 2分别对应着不同的含义， 如下：
 0 ： 标准输入，即：C中的stdin ， java中的System.in
 1 ： 标准输出，即：C中的stdout ，java中的System.out
 2 ： 错误输出，即：C中的stderr ， java中的System.err

PS: 在JDK1.5以上，我们可以通过在Java程序中调用Thread.getStackTrace()方法来进行堆栈的自动打印，使得线程堆栈的打印时机可编程控制。

 

## 15.JVM虚拟机有内存泄露怎么解决？

在C++ 语言中，如果需要动态分配一块内存，程序员需要负责这块内存的整个生命周期。从申请分配、到使用、再到最后的释放。这样的过程非常灵活，但是却十分繁琐，程序员很容易由于疏忽而忘记释放内存，从而导致内存的泄露。**Java语言对内存管理做了自己的优化，这就是垃圾回收机制。 Java的几乎所有内存对象都是在堆内存上分配（基本数据类型除外），然后由 GC（garbage collection）负责自动回收不再使用的内存。**

也许有人表示怀疑，既然 Java 的垃圾回收机制能够自动的回收内存，怎么还会出现内存泄漏的情况呢？这个问题，我们需要知道 GC 在什么时候回收内存对象，什么样的内存对象会被 GC 认为是“不再使用”的。

Java中对内存对象的访问，使用的是引用的方式。在 Java 代码中我们维护一个内存对象的引用变量，通过这个引用变量的值，我们可以访问到对应的内存地址中的内存对象空间。在 Java 程序中，这个引用变量本身既可以存放堆内存中，又可以放在代码栈的内存中（与基本数据类型相同）。 GC 线程会从代码栈中的引用变量开始跟踪，从而判定哪些内存是正在使用的。如果 GC 线程通过这种方式，无法跟踪到某一块堆内存，那么 GC 就认为这块内存将不再使用了（因为代码中已经无法访问这块内存了）。 

通过这种有向图的内存管理方式，当一个内存对象失去了所有的引用之后，GC 就可以将其回收。反过来说，如果这个对象还存在引用，那么它将不会被 GC 回收，哪怕是 Java 虚拟机抛出 OutOfMemoryError 。

**一般来说内存泄漏有两种情况**：

一种情况如在C/C++ 语言中的，在堆中的分配的内存，在没有将其释放掉的时候，就将所有能访问这块内存的方式都删掉（如指针重新赋值）

另一种情况则是在内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用）。

第一种情况，在 Java 中已经由于垃圾回收机制的引入，得到了很好的解决。所以， Java 中的内存泄漏，主要指的是第二种情况。

看一下这样的例子：

```java
Vector v = new  Vector( 10 ); 
for  ( int  i = 1 ;i < 100 ; i ++ ){ 
  Object o = new  Object(); 
  v.add(o); 
  o = null ; 
}
```

在这个例子中，代码栈中存在Vector 对象的引用 v 和 Object 对象的引用 o 。在 For 循环中，我们不断的生成新的对象，然后将其添加到 Vector 对象中，之后将 o 引用置空。问题是当 o 引用被置空后，如果发生 GC，我们创建的 Object 对象是否能够被 GC 回收呢？答案是否定的。

因为， GC 在跟踪代码栈中的引用时，会发现 v 引用，而继续往下跟踪，就会发现 v 引用指向的内存空间中又存在指向 Object 对象的引用。也就是说尽管o 引用已经被置空，但是 Object 对象仍然存在其他的引用，是可以被访问到的，所以 GC 无法将其释放掉。如果在此循环之后， Object 对象对程序已经没有任何作用，那么我们就认为此 Java 程序发生了内存泄漏。

尽管对于C/C++ 中的内存泄露情况来说， Java 内存泄露导致的破坏性小，除了少数情况会出现程序崩溃的情况外，大多数情况下程序仍然能正常运行。但是，在移动设备对于内存和 CPU 都有较严格的限制的情况下，Java 的内存溢出会导致程序效率低下、占用大量不需要的内存等问题。这将导致整个机器性能变差，严重的也会引起抛出 OutOfMemoryError ，导致程序崩溃。

在不涉及复杂数据结构的一般情况下，**Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度**。我们有时也将其称为“对象游离”。

**如果持有对象的强引用，垃圾回收器是无法在内存中回收这个对象。**

内存泄露的真因是：**持有对象的强引用，且没有及时释放，进而造成内存单元一直被占用，浪费空间，甚至可能造成内存溢出！**

**什么是强引用？**

Java的四种引用

**1.强引用：**是使用最普遍的引用：`Object o=new Object();` 特点：不会被GC。

**2.软引用`SoftReference：`**用来描述一些还有用但是并非必须的对象，在Java中用`java.lang.ref.SoftReference`类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。

**3.弱引用`WeakReference：`**与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，**一旦发现了只具有弱引用的对象**，不管当前内存空间足够与否，**都会回收它的内存**。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

**4.虚引用`PhantomReference：`**也称为幻影引用，一个对象是虚引用的存在都不会对生存时间构成影响，也无法通过虚引用来获取对一个对象的真实引用。唯一的用处：能在对象被GC时收到系统通知，Java中用`PhantomReference`来实现虚引用。

![å¨è¿éæå¥å¾çæè¿°](https://img.javatt.com/e8/e89945b9b3f9fa351431b39fd3337939.png)

 